# 问题

服务器上要限制某个IP每秒访问不能超过100次，如何高效的实现？

# 解读

遇到过注册机器人、短信轰炸机之类问题的同学，第一反应就是Redis(KV)计数器，IP转Int，作为键；值从0开始增加，加到一个业务设定的阀值，不好意思，不再提供你访问了……

但是，仔细一看，限制的IP每秒访问不能超过100次，显然，这是一个限流问题！（苦逼的小网站，几乎不需要考虑限流问题）

在突发流量的时候，整套服务架构无法满足庞大的访问量，这个时候，限流就是一种系统用来保护自己的方式，或者我可以称他为优雅降级（当然，这应该是降级的一种）。

而每秒100次调用感觉更像是应用服务器调用服务层的一种行为。

在这个过程中，阀值是100，时间周期为1秒。即1秒内只能接收100次请求，而多余的请求，我们要拒绝服务咯。

当然，能够显示出个人水平高低的要点，在于“高效实现”。

条条大路通罗马，关键看哪条路性价比更好。不同的实现方案，在于架构师的眼界、取舍、妥协。

# 思路

使用PHP的我，习惯性的技术栈是PHP+Redis的方案，索性就以这个角度描述整体的思路。

存储方面使用Redis的有序集合（sorted set），键使用IP，值为一些冗余请求信息，分数为请求时间戳（毫秒×1000）

当一条请求进来，首先删除当前时间点之前（0到当前时间戳）的所有集合元素，然后检查该IP的集合成员数量，大于等于100就说ByeBye。小于100则插入一条元素，值为当前毫秒时间戳（乘以一千作为score）。

# 本质

群里的大神们在讨论这个问题时，说到了一个关键词“漏桶原理”。

漏桶原理，其实就是，限制输出，抛弃输入。针对于这个问题，就是限制某个IP每秒的请求数，当超过100次的时候，就选择抛弃。

PS：

漏桶算法（Leaky Bucket）用于流量整形（Traffic Shaping）或速率闲置（Rate Limiting）。

令牌桶算法（Token Bucket），给请求做了标记，支持更多的处理方案。

# 高效

针对于提出的PHP+Redis的实现方案，对于我来说是一种简单可行效率也不差的方案。

而如果要追求“高效”（减少内网通讯的那几毫秒），我们需要做的是采用更高效的实现方案。

高效，意味着更轻巧的数据结构，更精细的内存控制，无网络请求！

通过C/C++实现一个链表，常驻内存，作为一个系统进程，自己时钟循环，淘汰过期数据，通过RPC，被调用（可以成为类似于PHP扩展的形式来实现，比如swoole）……

当然，用C去开发一个独立的服务看似高效，但是当我们的服务为了高可用，从单点做成分布式；为了防止数据丢失，需要落地到硬盘；为了方便调用，而开发大量其他语言的客户端SDK的时候……

随着需求的增加，我们似乎正在开发一款只有sorted set的定制性Redis，那为什么不直接使用已经相当可靠的Redis呢？

当然，如果对性能要求真的很高，一点点的性能提升都可以为我们节省几十台、上百台服务器的话，可能我们需要像facebook去创造HHVM一样去创作一个BucketServer吧！（HHVM对PHP的性能提升可不只是一点点-。-）
