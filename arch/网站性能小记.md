> **前言**
>
> 一个网站系统，在上线之初往往可以快速打开，响应迅速；而运行几年之后，数据量无时无刻不在增长，业务持续的更新变化，页面打开速度往往低的吓人，更有甚者会造成服务宕机。运维人员不得不无奈的上调服务器配置，开发者不得不四处研究到底发生了什么。

# 1 从一条HTTP请求说起

超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。属于OSI七层模型中的应用层。OSI七层模型从上到下分别为应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

关于OSI七层模型，参看下图：

![](../ppt/hide_img/osi.gif)

除此之外，还有一种分层方法被称为TCP/IP四层模型，简而言之就是将七层合并为应用层、传输层、网络层、网络接口层。

说白了，HTTP只是一种协议，方便客户端与服务端进行交流的规范。

**请求**Request

```http
GET /index.php HTTP/1.1
Host: www.sanhao.com
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0(X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/65.0.3325.181 Chrome/65.0.3325.181 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Referer: http://www.baidu.com/
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,ja;q=0.7,zh-TW;q=0.6
Cookie: uuid=1234567; PHPSESSID=abdcefg
If-Modified-Since: Tue, 17 Apr 2018 01:41:55 GMT

name=say&age=28&title=php&time=1234567890
```

**响应**Reponse

```http
HTTP/1.1 200 OK
Date: Tue, 17, Apr 2018 03:22:23 GMT
Content-Type: text/html; charset=utf-8
Transfer-Encoding: chunked
Connection: keep-alive
Vary: Accept-Encoding
Cache-Control: private, max-age=10
Expires: Tue, 17 Apr 2018 03:22:33 GMT
Last-modified: Tue, 17 Apr 2018 03:22:33 GMT
Content-Encoding: gzip

<!DOCTYPE html>
<html>
	<head>
		<title></title>
	</head>
	<body>
		<div id="main">Hello, World!</div>
	</body>
</html>
```

任何一个HTTP请求都分为请求头和请求体，GET方式请求体为空，头部会定义请求方式、URI、HTTP协议及协议使用版本，除此之外还会规定连接情况、客户端信息、Cookie、支持格式、编码格式、请求来源等。

响应头包含协议版本、状态码、返回信息、时间、连接方式、有效期、格式等，一般在响应体里面还会包含HTML代码。

HTTP大行其道，无论是客户端到服务端、还是服务端到服务端、都大面积在应用，了解HTML协议的同时，结合浏览器安全、Cookie机制等，可以从容有效的实现服务安全、单点登录、跨域安全、WebView免登录等。

[1]: https://www.cnblogs.com/wxgblogs/p/5641643.html	"七层协议和四层协议"

# 2 计算机的时间概念

正常人类一般使用的时间维度是时、分、秒，打开一个网页，主观的感觉是快与慢。但是一般来说根据功能与场景的不同；一般来说，一个页面不超过1秒，导出一份全年报表不超过1分钟，都可以被视作”快“。

而对于计算机来说，可以大致看作纳秒、微秒、毫秒。

CPU一级的一般使用纳秒；

内存读写、本地硬盘快速读写一般视作微秒（当然一般硬盘和内存在微秒层级还是存在倍数级性能差异的）；

局域网与互联网的消耗为毫秒……

以一条普通的三好网PHP的API服务请求为例（50ms，服务响应时间）

1. 客户端发起请求
   1. 数据压缩（受待压缩数据大小影响）
   2. dns解析（1us，受本机环路host配置影响）
   3. 建立连接（2ms，受网络延时影响）
   4. http请求传输（50us，受客户端到服务端的距离影响）
2. API服务器响应（50ms）
   1. aliyun负载均衡（5ms）
   2. 业务服务nginx（5ms）
   3. 反向代理fpm（1ms）
      1. 加载PHP RINIT（10ms, 受PHP版本、PHP框架代码初始化影响）
      2. PHP业务逻辑处理（20ms，参数验证、过滤、受逻辑复杂度、参数数量影响）
      3. Redis缓存检查
         1. Redis连接（5ms）
         2. Redis get（1ms）
         3. Redis数据返回（4ms）
      4. MySQL数据库查询/写入
         1. MySQL连接（5ms）
         2. MySQL SQL执行（10ms，受SQL复杂度、数据库服务器性能、数据量影响）
         3. MySQL数据返回（10ms）
      5. Redis种缓存（1ms）
      6. 第三方服务RPC（100ms，受第三方服务响应速度影响，跨外网，基本延时>20ms）
      7. 返回数据（5us）
   4. 数据返回nginx（5us）
3. 数据传输回客户端
   1. 数据传输（6ms，受数据大小影响）
   2. 数据解压（10us，受数据大小影响）
   3. 浏览器渲染（根据js、html、css代码实际情况影响）

以上数据仅为大致评估，不具备参考价值。由于负载均衡、PHP、MySQL、Redis是局域网；而Nginx与fpm之间是本机，所以在建立连接的步骤上，花去了较长的时间。而PHP本身受限于本身版本与采用框架的性能瓶颈，目前最快的响应速度为8ms。实际业务执行时，由于负担了数据的组装和业务逻辑处理的工作，所需时间会上升到20ms甚至更多。而服务中间件之间的数据传输则越少越快（比方我们常说的不用select *而是使用select id,name其实就是为了减少局域网间数据传输，同时还减少PHP内存占用）。

> **PS:**
>
> 由于不是任何业务都需要连接MySQL、Redis和第三方RPC，而部分接口使用缓存后，消耗时间仅在于PHP请求初始化和Redis的连接、get取缓存内容步骤，故接口的响应时间可以降低到20ms以下。

# 3 读与写

简单来说，任何业务都可以分为读与写。比方，我们在网站上看到一篇文章，就是读业务（无论是查询关系性数据库MySQL还是非关系性数据库Redis）；而在打开的时候，默认给当前页面的pageview进行+1操作，就是写业务。

不过，很多业务会即存在读业务又存在写业务，而为了保持事务性，我们没法进行简单的拆分（如在打开页面的时候之进行查询，打开页面后，通过ajax执行写业务给pageview++）。最直接的例子就是电商平台的下订单，下单的业务首先要查询商品的价格、商品数量、促销活动，在计算订单价格之后，生成订单（写入）。

所以，我们会根据读写比例来定义一个业务是读还是写——1:10是一个不错的比例！可以粗暴的理解为，写入一次，读取十次以上的就是读业务；反之即为写业务！

> **PS:**
>
> 这里对于读写业务的描述并不很令自己满意，但是可以理解为，下单过程中，写入订单数据后，读取的数量不会太多。

### 3.1 读

读，一般来说就是从RDBS（MySQL、MsSQL、Oracle）、NoSQL（Redis、Memcached、MongoDB）、本地文件系统（EXT*、NFTS）、分布式文件系统（HDFS，NFS）等中间件、系统或服务中获取数据。

一般来说读性能是：

Redis > MySQL > FileSystem > DFS

当然，这只是大致的一个顺序，很多时候读性能并不会完全遵照这一顺序。比方说文件系统被缓存起来（操作系统自动缓存），或MySQL的querycache开启情况下的二次查询（很多优化讲到要关闭MySQL的querycache，但是在我们目前的生产环境中并没有关闭，这里面有好处也有坏处）都会在性能方面不弱甚至强于内存数据库。

> **PS：**
>
> 由于一般情况下，线上服务PHP、MySQL、Redis、Hadoop等都是分别部署在不同的局域网服务器上，而文件系统则属于本地系统，所以无论PHP程序如何进行读，都要进行的是socket连接、发送查询请求、查询数据、返回数据、断开连接这几步。而内网的延时一定程度上决定了读的性能。当然，数据结构、服务器本身性能、查询数据量大小也决定了读的性能。
>
> 内网延时属于系统服务稳定性的一部分，一般不会有太大的优化价值，或者说优化的性价比较低；服务器性能由于不是所有公司都会有资金投入到机器上面，所以也属于技术人员不可控的性能优化点。
>
> 这时候，诸如MySQL引擎的选择，Redis数据对象的选择，查询语句优化，查询数量的压缩，查询逻辑的优化都会成为读业务的优化点。

以目前一般的网站系统的技术栈来说，存储方面使用的都是MySQL+Redis的组合形式。MySQL做为持久性存储，Redis作为内存数据库，多用于缓存或高并发存储使用。两者之间的性能差异在于MySQL最终会将数据落地到硬盘，而Redis数据存储于内存中，一旦宕机，数据的完整性会存在差异；而MySQL支持事务、锁等，可以保障顺序，而Redis则无法有效支持。在读性能上，特别是并发读取性能上，MySQL是落后于Redis的。

所以通常来说，为了支持更多的读，我们会选择加入缓存来让整个服务体系的读性能提升。

> **PS：**
>
> 缓存的形式有很多种，第四部分会详细介绍，这里不做展开。

### 3.2 写

读的数据都是需要写入的，所以写的重要性不容忽视。如何更快的写？如何写之后让读更快？MySQL借助redo log和undo log的方式变相的进行异步写入以达到保障写入效率的同时可以满足事务性要求（写入数据时还要维护索引数据）；Redis正常读写都在内存中进行，减少了磁盘I/O的性能瓶颈，同时异步的将内存中的数据还存在日志文件中（AOF、RDB）；而最简单的文件系统，直接打开本地文件，写入，关闭句柄（会出现写占用问题）。

相对于“单纯”一些的读，写看似简单的写可能要做很多其他工作，让读可以保持“单纯”。

#### 3.2.1 文件系统

我们可以根据自己的需求，构造一个简单的文本数据库，通过目录结构与文件来存储数据，通过命名来定义规则，方便文件查找，从而查询出存储于文件中的文本。可以想象成使用了OSS，存储了一堆json文件，每个json里面存储的就是一条数据。

```http
http://oss.sanhao.com/article/1.json
```

可以理解为这是文章信息的第一条，我们在做简单查询的时候可以通过数据编号很快的找到想要的文件，然后进行读写操作。但是，对于复杂的查询，比方说条件查询、筛选等，文件系统就无法满足我们的需求了。虽然我们可以自己去一点点的实现这些功能，但是做到最后，会发现我们不知不觉中又做了一个关系性数据库，而且是劣化版本的，那么为什么不一开始就使用MySQL呢？

不过，通过这种简单的目录结构路由形式，在很多场景下，反而成为了一种优势。

#### 3.2.2 Redis

其实和文件系统很类似，Redis提供内存数据的存储，虽然提供多种存储类型，但是本质上都可以看做key-value的形式。



> **PS:**
>
> OSS是阿里云提供的对象存储服务（Object Storage Service）



# 4 银弹“缓存”

# 5 异歩写入

# 6 MySQL

## 6.1 B+树与索引

## 6.2 数据库字段小TIP

## 6.3 慢查询

#7 复杂业务

## 7.1 查询压力

##7.2 数据冗余

##7.3 可维护性

# 8 结尾

