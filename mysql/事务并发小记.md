# 从很久很久以前

三好网初期的定位是一个电子商务网站，B2C、C2C或者说C2B2C。

所以库存(sku)和订单(order)、支付(pay)就是无论如何都绕不过去的问题了。

当然，因为是做在线教育的，所以方式方法上和传统的电子商务除了相似的地方外，也存在很多的区别

1. 商家，我们的商家是教师，类似于淘宝的店主
2. 商品，我们的商品是教师发布的课程，类似于淘宝店主贩售的商品
3. 库存，我们的库存是教师的可用时间，更类似于12306的车票，需要具有唯一性
4. 订单，我们的订单包含用户买了哪个教师的课时，花了多少钱，以及相关的状态
5. 子订单，我们的子订单是用户基于订单每一次预约课程的记录，以及教师上课的结算凭证
6. 状态，和传统电子商务的状态不同，我们的订单一般具有较长的时间周期，一个订单可能具有60、100小时的时长，用户需要连续上课长达一年之久才能完成一个订单，当然，也可以买一节上一节。

# 并发点

在一般的网站业务中，并发读对于架构师来说，可能是一种很基本的需求。了解业务特性、业务并发点，对于我们如何来进行架构设计一个高可用高并发的系统来说是必需的。

这些并发的点只针对于用户选择老师、购买课程并支付这个“购物”流程；对于整个三好网来说，并发的点还有很多,但是“购物”这个流程基本上可以包含绝大多数的点，具备代表性。

## 读

1. 教师工作室（我更愿意称之为教师详情页，包括教师信息、相关信息、评价信息、推荐信息、课程信息）
2. 教师可用时间片（库存）
3. 订单查询、课表查询（课表本质上是基于订单与子订单的不同显示）

针对教师详情页而言，基本上是一个读多写少的业务。而针对于并发读，我们要做的就是“缓存”。

1. NoSQL、文件缓存
2. PHP性能提升
3. 页面静态化
4. CDN
5. 浏览器缓存

对于三好网来说，我们使用Redis作为内存缓存，将API接口服务提供的返回结果直接使用KV进行存储，在接收到请求时，不是去读取数据库，而是直接从内存（数据库）中讲数据返回，从而提高并发能力。

Redis提供了一个共享缓存，无论我们有多少个API服务器，都可以共享一个Redis内存数据库，而单独API服务本身，则可以通过文件缓存来将返回结果存储到文件中。由于是文件操作系统，在第一次请求过来的时候，会直接将文件读入内存中，在操作系统内存充足的情况下，我们的缓存效率相当于内存数据库。

当然，PHP是解释性脚本语言，如果想要单台服务器能够承载更多的并发访问，我们接下来要做的事情有几种选择：APC（缓存opcode）、升级（PHP7的效率远远高于PHP5）、HHVM（PHP的一些hack，类似于Java中JVM的）。无论是缓存opcode还是虚拟机，都会让PHP的最大优势（自由灵活）受到限制，而升级到PHP7，则对于公司技术部的运维配置、代码迁移成本和团队成员来说是一种不小的挑战（我们的开发人员实在是有点少-。-）。

所以，页面静态化对我们来说是一种很简单、便捷的缓存形式。说到静态化，大家想到的就是写页面、套模板、生成html。考虑到项目已经很庞大了、团队开发形式不能轻易改变（任何调整都需要一步步来，不然阻力真心很大）、传统的静态化方式（Smarty之类的）真心浪费PHP的优势（PHP本身就是一个模板一样的，再套一层真心让人觉得很蛋疼）。

而静态化之后，我们可以通过CDN（内容分发网络）来在各个节点（互联网是网状结构的）增加静态文件的缓存，保证一些热点数据可以缓存在离用户最近的地方。

而最后，我们则要灵活使用浏览器缓存，除了常规的通过http协议告知浏览器对页面的缓存之外，H5的流行（localStorage和sessionStorage）和前端（js）MVC思想的运用可以为我们提供强大的缓存能力，从而提高系统并发读的能力。

## 写

1. 教师时间片（库存）的更新（添加、锁定、解锁）
2. 订单的添加、变更
3. 支付的处理（支付单的生成）
4. 用户信息（余额、用户优惠券）变更
5. 收支记录（财务流水相关）

在用户购买下单支付的整个流程中，库存、状态集、并发（多个学生同时购买了同一个老师的同一段时间片）、事务（用户下单的时候，库存要锁定、订单要生成；支付的时候，订单状态要变更，支付单要生成等）等名词都不可避免的出现在我们的眼前。

在数据的持久化存储方面，我们使用的是主流的MySQL。在三好网目前这个量级下，同步数据事务操作，是完全可以满足我们的功能需求的。而在更大的并发写压力下，我们要做的是异步数据操作，对于是否是事务操作，这里要根据实际的业务来决定（我个人倾向于优先使用事务，借助数据库来解决一些锁的问题，以保证事务的acid），当然，在秒杀、抢购一类的业务中，传统关系型数据库（MySQL Innodb）最终会出现瓶颈，这个时候，我们可以采用NoSQL内存数据库来提高并发写能力（Redis作为内存数据库提供数据存储，然后异步存储到MySQL）。

在数据库设计方面，最早，教师时间片（库存）是每两小时一个片段，作为一条记录存储在数据表中的，每天支持，早上六点到晚上二十四点；订单信息、支付信息则是按照一单一条进行记录的。

而创业公司嘛，业务的修改是很正常的，教师时间片就是第一次强烈撕逼，最后我们不得不屈服于业务需求，教师时间片每半小时作为一片段，支持全天24小时的库存存储、添加、锁定、使用。

当然，问题并不仅仅是这样子的，在开发了批量添加时间片功能后，当时，我们只有几百名教师的系统，突然有了百万条的时间片数据。

批量添加，支持批量添加三个月、半年、一年甚至更久，而助教同学们很热心的帮老师批量添加了大面积的时间片-。-（我真的没有黑的意思）

然后，随着业务推广，老师的数量逐渐增加，时间片的数量也疯狂的增长中；改变存储结构，也就成了一种必然。

在经过讨论和分析之后，我们决定使用二进制存储时间片段（巧合的是，24小时，每半小时一片，一天48个时间片，一个int刚好可以存储三分之一，3个int就可以完美存储48个时间片及每个时间片的四种状态）

00 未发布、01 发布、10 预留、11被锁定

这样，原本一个老师一天的时间片需要48条记录,而现在只需要一条记录就可以搞定，存储效率提升了40倍。

百万条的记录，短时间内，变成了万级。

### 下单的坑

### 支付的坑

做过支付的同学基本都清楚，我们预留一张支付单，填写需要付款额度、付款方式、然后如果余额支付，那就完成支付了，如果是第三方支付，就要等待第三方的回调了。程序逻辑进来，检查请求有效性，核对支付单信息（看下支付单状态是什么，再看下支付单的回调额度是不是对的），然后没问题了，修改支付单状态。

看上去似乎没什么问题，然而呢？？

支付宝和财付通居然存在并发回调问题-。-！

而很不凑巧的，我们遇到了这种问题……

